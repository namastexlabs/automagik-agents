---
description: Build self-contained tools for the agent runtime
globs: ["src/tools/**/*.py", "tests/tools/**/*.py"]
alwaysApply: false
---

Automagik Tool Development Rules
===============================

*(This file has been moved from `develing_tools.mdc` to follow the new structure.)*

Follow **all** of the guidelines below when adding or updating anything inside the `src/tools/` package.  The goal is to keep every tool self-contained, type-safe and easily discoverable by the agent runtime.

1. Directory Structure
----------------------
Each tool lives in its **own sub-package**:

```
src/tools/<tool_name>/
    __init__.py      # re-export `<tool_name>_tools`
    schema.py        # pydantic input / output models
    provider.py      # (optional) low-level API integration
    tool.py          # async business logic functions
    interface.py     # wraps functions in pydantic_ai.tools.Tool objects
```

• **Never** place multiple logical tools in the same folder.            
• Keep HTTP / SDK code in `provider.py`; business logic in `tool.py`.

2. Async Functions & RunContext
-------------------------------
• Every callable exposed to the agent **MUST** be declared

```python
async def my_tool(ctx: RunContext[Dict], <parameters>) -> Dict[str, Any]:
```

• Always accept `ctx` as the first argument (even if unused).            
• **Do not** raise exceptions – catch and return a response model with
  `success=False` and an `error` field.

3. Schema Definitions
---------------------
• Define a dedicated Pydantic model for **every** input and output type
  inside `schema.py`.
• Response models **must** contain a top-level boolean `success` field.
• Convert models to primitives via `.dict()` **before** returning from
  the tool entry point.

4. Description Helpers
----------------------
For every exported function add a small helper that returns its
human-readable description:

```python
def get_search_files_description() -> str:
    return "Search for files in Google Drive by query."
```

5. Tool Registration (interface.py)
-----------------------------------
• Wrap each function with `pydantic_ai.tools.Tool`, e.g.

```python
search_files_tool = Tool(
    name="google_drive_search_files",
    description=get_search_files_description(),
    function=search_files,
)
```

• Collect all tool objects in a list called `<tool_name>_tools` and
  export it from `__init__.py`.

6. Global Registration
----------------------
After creating the tool package **add the list variable** to
`src/tools/__init__.py.__all__` so the agent loader can pick it up.

⚠️ **Special case — Memory tools**
The historic `memory` package predates this convention and exports *individual helper
functions* (`read_memory`, `create_memory`, …) instead of a single
`memory_tools` list.  The loader treats these functions as built-ins, so
rule 6 is considered satisfied for that package.

7. Configuration & Secrets
--------------------------
**NEVER** read environment variables directly.  Import settings from the
central config module instead:

```python
from src.config import settings
api_key = settings.GOOGLE_API_KEY
```

*Remember*: Using `os.environ.get()` or similar inside any tool **will break the rule-enforcer and fail CI*.

8. Logging
----------
• Import `logging` and log **at least** at INFO level for every external
  call and at ERROR level inside exception handlers.

9. Naming Conventions
---------------------
• Use `snake_case` for all function and variable names.            
• Prefix tool objects with the package name (e.g. `gmail_send_email_tool`).

10. Extensibility Principle
---------------------------
If you need shared behaviour, **extend** via helpers or base classes in
your own package.  **Do not** modify third-party libraries or existing
packages unless absolutely necessary and approved by maintainers.

11. Tests
---------
• Add unit tests for every new tool covering success and failure paths.

12. When in Doubt
-----------------
Ask yourself:
1. Can this logic live entirely inside a tool package?  
2. Does it respect the config & async rules?  
3. Is it discoverable via `__all__`?

Only merge when the answer to all three is **yes**.

---
## 13. Anatomy of a Real-World Tool (Gmail example)

```
src/tools/gmail/
├── schema.py      # SendEmailInput, SendEmailResult, … (pydantic models)
├── provider.py    # OAuth flow + low-level Google API calls
├── tool.py        # async send_email(ctx, input) → Dict
├── interface.py   # gmail_send_email_tool = Tool(…)
└── __init__.py    # re-exports gmail_tools list so loader can pick it up
```

Key take-aways:

1. **Provider isolation** – all HTTP & OAuth code lives in `provider.py`, never inside `tool.py`.
2. **Context first** – `send_email(ctx, input)` starts by logging via `logger.info`.
3. **Error path** – catches **any** exception and returns a `SendEmailResult(success=False, error=…)` model → `.dict()`.
4. **Interface layer** is responsible for human-readable description and mapping to `Tool` object.

---
## 14. Wrapper vs. Native Tool

Sometimes you only need a *thin wrapper* around an existing SDK call (e.g. Blackpearl `verificar_cnpj`).

Guideline:

* If latency is negligible and logic is < 10 lines → write a **wrapper function** in `interface.py` and register directly.
* If you require retries, pagination or auth refresh → implement a full `provider.py` + `tool.py` pair.

---
## 15. Creating a New Tool – Checklist

1. `mkdir -p src/tools/<tool_name>`
2. Write `schema.py` with **input & output** pydantic models (output includes `success: bool`).
3. Implement **provider.py** for external API chatter (optional).
4. Implement **tool.py** with one or more `async def` entry points:
   * First param **must** be `ctx: RunContext[Dict]`.
   * Return `.dict()` from your output model.
5. Implement **interface.py**:
   ```python
   from pydantic_ai.tools import Tool
   from .tool import send_foo, get_send_foo_description

   send_foo_tool = Tool(
       name="<namespace>_send_foo",
       description=get_send_foo_description(),
       function=send_foo,
   )

   <tool_name>_tools = [send_foo_tool]
   ```
6. Add exports in `src/tools/__init__.py`:
   ```python
   from .<tool_name> import <tool_name>_tools
   __all__.append("<tool_name>_tools")
   ```
7. Write **unit tests** under `tests/tools/<tool_name>/` using `pytest-aiohttp` or recorded fixtures.

---
## 16. Danger Zones

• Forgetting to convert pydantic models to primitives → Agents receive `ValidationError`.
• Using blocking SDKs inside `tool.py` – always `async`/await or run in threadpool.
• Returning raw exception objects; always wrap in `{success=False, error=str(e)}`.
• Omitting the tool list export in `__init__.py` → loader silently ignores your tool.

---
## 17. Tool Loader Internals (FYI)

The factory that aggregates tools:

```
src/tools/__init__.py → __all__ list
src/agents/models/tool_registry.py → discovers *
```

It imports each `<tool_name>_tools` list and flattens them.  If your list variable name doesn't match the folder, it won't load.
