---
description: How to create or extend Automagik agents
globs: ["src/agents/**/*.py", "tests/agents/**/*.py", "src/agents/**/prompts/**/*"]
alwaysApply: false
---

# Automagik Agent Development Rules

*(This file has been moved from `automagik-agent-development.mdc` to follow the new structure.)*

## Core Principle

When developing or modifying agents (e.g., `simple_agent`), always **extend** rather than **modify** base functionality from `AutomagikAgent`. This ensures maintainability across all agents by keeping shared functionality intact.

## 0. Anatomy at a Glance

```
src/agents/
├── models/                 # Abstract base + shared helpers
└── simple/                 # Reference implementations
    ├── simple_agent/      # "Hello-world" style template
    ├── stan_agent/        # Full CRM + Blackpearl integration (📞 phone-centric)
    ├── sofia_agent/       # Advanced WhatsApp (Evolution) flow ✅ production-ready
    ├── flashinho_agent/   # Lightweight "Flashed" memory demo
    ├── discord_agent/     # Discord chat-bot persona
    ├── prompt_maker_agent/ # Meta-agent that generates prompt templates
    ├── stan_email_agent/  # Email-centric CRM assistant
    └── estruturar_agent/  # Structured-conversation Portuguese demo
```

* Clone **simple_agent** for quick prototypes.
* Clone **stan_agent** when you need multi-prompt logic, tool wrappers and DB persistence.
* Clone **sofia_agent** when building **WhatsApp/Evolution**-enabled personas (handles phone numbers, reactions, media, etc.).

## 1. Base-Class Contract (`AutomagikAgent`)

Every concrete agent **must** implement or override the following:

1. `async initialize_prompts()` – register or load system prompts.  Keep it **idempotent**.
2. `async run(input_text: str, …) -> AgentResponse` – core execution.  Always return `AgentResponse`; never naked strings.
3. `tool_registry.register_default_tools(self.context)` – call this in `__init__` to ensure search/memory tools are present.
4. If you create additional tool wrappers, add them through `self.tool_registry.register_tool(wrapper_fn)`.

## 2. Sofia-Agent Playbook (WhatsApp)

Sofia illustrates the full **WhatsApp → Evolution → Tool → LLM** loop.

Key patterns to copy:

1. **EvolutionMessagePayload**
   ```python
   from src.agents.common.evolution import EvolutionMessagePayload
   payload = EvolutionMessagePayload(**channel_payload)
   self.context["evolution_payload"] = payload
   ```

2. **Auto-wrapping Evolution tools** so agents don't need to ask for JIDs:
   ```python
   def _create_send_text_wrapper(self):
       from src.tools.evolution.tool import send_message

       async def send_text(ctx: RunContext[AutomagikAgentsDependencies], text: str):
           phone = ctx.evolution_payload.get_user_number()
           return await send_message(ctx, phone, text)
       return send_text
   ```

3. **Prompt injection**: Sofia stores user info in `Memory` (name, phone) → referenced via `{{user_information}}` template vars.

4. **Multimodal support**: converts incoming image URLs to `ImageUrl` / `BinaryContent` before passing to Pydantic-AI.

## 3. Stan-Agent Playbook (CRM-heavy)

Demonstrates:

• **Multiple prompt versions** keyed by contact status (`NOT_REGISTERED`, `APPROVED`, …).  Prompts live in `prompts/*.py` and are auto-registered at startup.

• **Sub-agents as tools**: Product / Order / Backoffice agents are exposed via lightweight wrapper functions so Stan can delegate.

• **Blackpearl integration**: Uses `blackpearl.*` tools plus a custom `verificar_cnpj` wrapper.

• **Dynamic dependencies**: `AutomagikAgentsDependencies` gets `usage_limits`, `agent_id`, and channel context injected before every LLM call.

## 4. Checklist for Creating a New Agent

1. `mkdir -p src/agents/simple/<your_agent>`
2. Create `agent.py` inheriting `AutomagikAgent`.
3. Copy the minimal template from `simple_agent` **or** start from Stan/Sofia if you need their features.
4. Add `__init__.py` with `__all__ = ["<YourAgent>"]`.
5. Register default tools and any wrappers in `__init__`.
6. Place prompt template(s) in a `prompts/` subfolder — name `prompt.py` for default, others upper-case for status keys.
7. (Optional) The Simple-agent factory **auto-discovers** any sub-folder that exposes a `create_agent()` function, so manual edits to `src/agents/simple/__init__.py` are usually unnecessary.  Only touch that file if you need custom loading logic.
8. Write at least one **unit test** under `tests/agents/` that instantiates the agent and calls `run()` with dummy input.

## 5. Danger Zones (common mistakes)

• Forgetting to pass `ctx` as first arg in tool wrappers → runtime validation fails.
• Accessing environment vars directly inside an agent (`os.getenv`) instead of using `settings`.
• Returning raw strings instead of `AgentResponse`.
• Neglecting to copy DB `evolution_payload` into dependencies → WhatsApp tools break.

## 6. Further Reference

• Stan sub-agents: `src/agents/simple/stan_agent/specialized/*`
• Sofia Airtable wrapper: `src/agents/simple/sofia_agent/specialized/airtable.py`
• Agent factory: `src/agents/models/agent_factory.py` – how classes are discovered & instantiated.

## Class Hierarchy

```
AutomagikAgent (abstract base class)
  │
  ├── SimpleAgent
  ├── SpecializedAgent
  └── [Other agent implementations]
```

## Rules for Agent Development

### 1. Override Methods, Don't Modify Base Class

**CORRECT ✅**: Override methods in your specific agent class
```python
# In simple_agent/agent.py
class SimpleAgent(AutomagikAgent):
    async def run(self, input_text: str, **kwargs) -> AgentResponse:
        # Your customized implementation here
        return await super().run(input_text, **kwargs)
```

**INCORRECT ❌**: Directly modifying methods in AutomagikAgent
```python
# Don't do this - modifying src/agents/models/automagik_agent.py
class AutomagikAgent(ABC, Generic[T]):
    async def run(self, input_text: str, **kwargs) -> AgentResponse:
        # Adding specific functionality here affects ALL agents
```

### 2. Extending Base Functionality

If you need new shared functionality, add it through clean extensions:

1. First, determine if the functionality belongs to all agents or just yours
2. If it's agent-specific, implement it in your agent class
3. If it should be shared, add methods to the base class that allow overriding

### 3. When Base Changes Are Truly Needed

If a base class change is truly required:

1. Document the reason thoroughly in the PR
2. Ensure backward compatibility
3. Update all affected agent implementations
4. Add unit tests for the base class and all implementations

## Examples

### Example: Adding New Message Handling

**Good implementation** (extending in your agent):
```python
class MyAgent(AutomagikAgent):
    async def process_message(self, user_message, **kwargs):
        # Pre-process the message in a way specific to this agent
        parsed_message = self._my_custom_parser(user_message)
        
        # Then call the parent method
        return await super().process_message(parsed_message, **kwargs)
        
    def _my_custom_parser(self, message):
        # Agent-specific parsing logic
        return processed_message
```

### Example: Tool Registration

**Good implementation** (using existing hooks):
```python
class MyAgent(AutomagikAgent):
    def __init__(self, config, system_prompt):
        super().__init__(config, system_prompt)
        
        # Register agent-specific tools
        self.register_tool(my_custom_tool)
        self.register_tool(another_custom_tool)
```

## Benefits

- **Maintainability**: Changes to one agent don't affect others
- **Extensibility**: Easy to add new agent types with custom behavior
- **Testing**: Clearer boundaries make testing more straightforward
- **Collaboration**: Multiple developers can work on different agents

## When in Doubt

If unsure whether a change should be in the base class or in a specific agent implementation:

1. Does every current and future agent need this behavior exactly as implemented?
2. Is this truly generic functionality with no agent-specific assumptions?
3. Can the functionality be made generic with hook points for customization?

Only if all three answers are "yes" should you consider modifying the base class.
