---
description: Memory API commands, template variables, and query patterns for automagik-agents
globs: src/memory/**/*,src/agents/**/*,tests/**/*memory*,tests/**/*agent*
alwaysApply: false
---
# Memory References - Graphiti

## 🧠 Graphiti Memory Architecture

**Documentation**: [memory.md](mdc:docs/memory.md) | [database.md](mdc:docs/database.md) | [agents_overview.md](mdc:docs/agents_overview.md)

### **Core Components**
- **Knowledge Graph**: Entity-relationship based memory storage
- **Nodes**: Preferences, Procedures, Requirements, and other entities
- **Facts**: Relationships and factual connections between entities
- **Episodes**: Structured data inputs (text, json, message)
- **Session Management**: Multi-user conversation isolation
- **Template System**: `{{variable}}` injection into prompts

**Memory Flow**: Search → Apply → Capture → Store → Enhance

## 🔍 Memory Search Commands

### **Search Nodes** (Entities)
```bash
mcp_agent-memory_search_memory_nodes \
  --query "search terms" \
  --entity "Preference|Procedure|Requirement" \
  --max_nodes 10
```

**Entity Types**:
- **Preference**: User preferences and settings
- **Procedure**: Step-by-step workflows
- **Requirement**: Project requirements and constraints

**Strategic Query Patterns**:
- **Preferences**: `"user preferences formatting|coding style|communication"`
- **Procedures**: `"procedure deploy|setup workflow|testing steps"`
- **Requirements**: `"requirement authentication|API constraints|security"`

### **Search Facts** (Relationships)
```bash
mcp_agent-memory_search_memory_facts \
  --query "relationship terms" \
  --max_facts 10 \
  --center_node_uuid "node-uuid"  # Optional: explore around specific node
```

**Fact Query Examples**:
- **Dependencies**: `"depends on|requires|needs"`
- **Connections**: `"related to|connected with|associated"`
- **Ownership**: `"owned by|belongs to|created by"`

## 💾 Memory Storage Commands

### **Add Episode** (Primary Storage)
```bash
# Text content
mcp_agent-memory_add_memory \
  --name "Episode Name" \
  --episode_body "Content to store" \
  --source "text" \
  --source_description "Context description"

# JSON structured data
mcp_agent-memory_add_memory \
  --name "API Configuration" \
  --episode_body "{\\\"api\\\": {\\\"endpoint\\\": \\\"https://api.example.com\\\"}}" \
  --source "json" \
  --source_description "API settings"

# Message/conversation format
mcp_agent-memory_add_memory \
  --name "User Conversation" \
  --episode_body "user: How should I format code?\nassistant: Use Black formatter" \
  --source "message" \
  --source_description "formatting preference discussion"
```

### **Episode Best Practices**
- **Split long content**: Break requirements into logical chunks
- **Be explicit about updates**: Only add what's new or changed
- **Use appropriate source type**: text, json, or message
- **Add descriptive names**: Help future searches
- **Include context**: source_description for clarity

## 🏗️ Development Workflow with Memory

### **1. Before Starting ANY Task**
```bash
# Search for preferences
mcp_agent-memory_search_memory_nodes --query "task keywords" --entity "Preference"

# Search for procedures  
mcp_agent-memory_search_memory_nodes --query "workflow steps" --entity "Procedure"

# Search for related facts
mcp_agent-memory_search_memory_facts --query "connections dependencies"
```

### **2. During Development**
```python
# When user expresses preference
mcp_agent-memory_add_memory \
  --name "Code Style Preference" \
  --episode_body "User prefers type hints on all functions" \
  --source "text"

# When discovering procedure
mcp_agent-memory_add_memory \
  --name "Deployment Procedure" \
  --episode_body "1. Run tests\n2. Update version\n3. Build Docker image\n4. Deploy to staging" \
  --source "text"

# When learning relationships
mcp_agent-memory_add_memory \
  --name "Component Dependencies" \
  --episode_body "{\\\"agent\\\": {\\\"depends_on\\\": [\\\"memory_manager\\\", \\\"tool_registry\\\"]}}" \
  --source "json"
```

### **3. After Task Completion**
```bash
# Store successful patterns
mcp_agent-memory_add_memory \
  --name "Successful Agent Pattern" \
  --episode_body "AutomagikAgent extension with custom tool registration worked well for Discord integration" \
  --source "text"

# Document discovered constraints
mcp_agent-memory_add_memory \
  --name "API Rate Limit Discovered" \
  --episode_body "{\\\"constraint\\\": {\\\"api\\\": \\\"discord\\\", \\\"rate_limit\\\": \\\"50/minute\\\"}}" \
  --source "json"
```

## 🏷️ Template Variables Integration

### **Memory-Enhanced Templates**
```python
SYSTEM_PROMPT = """You are helping {{user_name}}.

# From memory searches:
Preferences: {{user_preferences}}
Current Procedure: {{active_procedure}}
Constraints: {{known_requirements}}

Recent: {{recent_context}}
Task: {{current_task}}

Available tools: {tools}"""
```

### **Dynamic Memory Injection**
```python
class MemoryEnhancedAgent(AutomagikAgent):
    async def enhance_prompt_with_memory(self, base_prompt: str, query: str):
        # Search relevant preferences
        prefs = await search_memory_nodes(
            query=query,
            entity="Preference",
            max_nodes=5
        )
        
        # Search applicable procedures
        procedures = await search_memory_nodes(
            query=query,
            entity="Procedure",
            max_nodes=3
        )
        
        # Inject into prompt
        return base_prompt.replace(
            "{{user_preferences}}", 
            "\n".join(pref['summary'] for pref in prefs)
        )
```

## 🧪 Memory Testing Patterns

### **Graph Memory Testing**
```python
@pytest.mark.asyncio
async def test_memory_graph_storage():
    # Add preference episode
    await add_memory(
        name="Test Preference",
        episode_body="User prefers detailed error messages",
        source="text"
    )
    
    # Search for it
    nodes = await search_memory_nodes(
        query="error messages",
        entity="Preference"
    )
    
    assert len(nodes) > 0
    assert "detailed error messages" in nodes[0]['summary']
```

### **Relationship Testing**
```python
@pytest.mark.asyncio
async def test_memory_relationships():
    # Add related entities
    await add_memory(
        name="Component Relationships",
        episode_body='{"agent": {"requires": ["memory", "tools"]}}',
        source="json"
    )
    
    # Search facts
    facts = await search_memory_facts(
        query="agent requires"
    )
    
    assert any("requires" in fact['fact'] for fact in facts)
```

## 📋 Memory Best Practices

### **Search Strategy**
1. **Always search first**: Before any task, search nodes and facts
2. **Use entity filters**: Target Preference, Procedure, or Requirement
3. **Combine searches**: Use both node and fact searches for context
4. **Center explorations**: Use center_node_uuid for related info
5. **Respect findings**: Align work with discovered knowledge

### **Storage Guidelines**
1. **Immediate capture**: Store preferences/procedures as discovered
2. **Structured data**: Use JSON source for complex relationships
3. **Clear categorization**: Label with appropriate entity types
4. **Update explicitly**: Only add new/changed information
5. **Context included**: Always add source_description

### **Common Patterns**

**Storing User Preferences**:
```bash
mcp_agent-memory_add_memory \
  --name "Communication Style" \
  --episode_body "User prefers concise technical explanations with code examples" \
  --source "text" \
  --source_description "User feedback on explanation style"
```

**Documenting Procedures**:
```bash
mcp_agent-memory_add_memory \
  --name "Agent Testing Procedure" \
  --episode_body "1. Unit test agent initialization\n2. Test tool registration\n3. Integration test with API\n4. Test memory persistence" \
  --source "text" \
  --source_description "Standard testing workflow"
```

**Recording Requirements**:
```bash
mcp_agent-memory_add_memory \
  --name "Security Requirements" \
  --episode_body "{\\\"security\\\": {\\\"auth\\\": \\\"API key required\\\", \\\"rate_limit\\\": \\\"100/hour\\\"}}" \
  --source "json" \
  --source_description "API security constraints"
```

## 🎯 Strategic Memory Usage

### **Development Cycle Integration**
1. **Pre-task**: Search nodes for context
2. **During task**: Capture discoveries immediately
3. **Post-task**: Store patterns and solutions
4. **Review**: Search facts for impact analysis

### **Memory-Driven Decisions**
```python
# Example: Check preferences before suggesting
preferences = search_memory_nodes(query="code style", entity="Preference")
if any("type hints" in p['summary'] for p in preferences):
    # Generate code with type hints
```

### **Continuous Learning**
- **Pattern Recognition**: Store repeated implementations
- **Error Prevention**: Document solutions to problems
- **Optimization**: Record performance improvements
- **Team Knowledge**: Share discoveries via memory

---

**Remember**: The knowledge graph is your persistent memory. Always search before starting, respect discovered preferences and procedures, capture new knowledge immediately, and use structured data for complex relationships.
