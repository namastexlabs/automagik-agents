---
description: Daily development workflow, mode switching, and implementation patterns for automagik-agents
globs: src/**/*,tests/**/*,*.py,*.md
alwaysApply: false
---
# Development Workflow

## ğŸ”„ Daily Development Workflow

**Documentation**: [setup.md](mdc:docs/setup.md) | [running.md](mdc:docs/running.md) | [agents_overview.md](mdc:docs/agents_overview.md)

**Standard Process:**
1. **Start**: Search memory for context â†’ Check Linear tasks â†’ Understand requirements
2. **Plan**: Search procedures â†’ Break down complex tasks â†’ Create subtasks
3. **Implement**: Follow discovered procedures â†’ Code â†’ Test
4. **Progress**: Store discoveries â†’ Update Linear â†’ Document patterns
5. **Complete**: Save successful patterns â†’ Update task status â†’ Generate updates

**Memory-First Approach:**
```bash
# Before starting any task
mcp_agent-memory_search_memory_nodes --query "task keywords" --entity "Procedure"
mcp_agent-memory_search_memory_nodes --query "preferences" --entity "Preference"
mcp_agent-memory_search_memory_facts --query "dependencies relationships"
```

## ğŸ¯ Development Modes

### Code Mode
- **Focus**: Implementation, file editing, testing
- **Memory**: 
  ```bash
  mcp_agent-memory_search_memory_nodes --query "code patterns implementation" --entity "Procedure"
  mcp_agent-memory_search_memory_nodes --query "coding style" --entity "Preference"
  ```
- **Pattern**: Extend AutomagikAgent, use {{memory_templates}}, register tools
- **Trigger**: Implementation tasks, bug fixes, feature coding

### Architect Mode  
- **Focus**: Analysis, design, planning
- **Memory**: 
  ```bash
  mcp_agent-memory_search_memory_nodes --query "architecture design patterns" --entity "Procedure"
  mcp_agent-memory_search_memory_facts --query "component relationships dependencies"
  ```
- **Constraint**: .md files only, high-level planning
- **Trigger**: System design, structure planning, documentation

### Debug Mode
- **Focus**: Problem diagnosis, systematic analysis
- **Memory**: 
  ```bash
  mcp_agent-memory_search_memory_nodes --query "debug troubleshoot error" --entity "Procedure"
  mcp_agent-memory_search_memory_facts --query "error caused by solution"
  ```
- **Pattern**: 5-7 hypotheses â†’ 1-2 likely â†’ add logs â†’ validate
- **Trigger**: Bugs, unexpected behavior, performance issues

### Test Mode
- **Focus**: Test execution, coverage, validation  
- **Memory**: 
  ```bash
  mcp_agent-memory_search_memory_nodes --query "test patterns validation" --entity "Procedure"
  mcp_agent-memory_search_memory_nodes --query "test requirements" --entity "Requirement"
  ```
- **Pattern**: Use test criteria from Linear issue description
- **Trigger**: Verification, quality assurance, CI/CD

## ğŸš€ Creation Checklists

### **Agent Development** (8-Step Process)
1. **Search Memory**: Check for existing agent patterns and preferences
   ```bash
   mcp_agent-memory_search_memory_nodes --query "agent development" --entity "Procedure"
   ```
2. **Directory**: `mkdir -p src/agents/simple/<agent_name>`
3. **Structure**: Create `agent.py`, `prompts/prompt.py`, `__init__.py`
4. **Agent Class**: Extend `AutomagikAgent` with proper initialization
5. **System Prompt**: Define with `{{memory_templates}}`
6. **Tools**: Register default + custom tools if needed
7. **Export**: Export from `__init__.py` for auto-discovery
8. **Document**: Store pattern if new approach used
   ```bash
   mcp_agent-memory_add_memory --name "Agent Pattern: [Name]" --episode_body "pattern details" --source "text"
   ```

### **Tool Development** (8-Step Process)
1. **Search Memory**: Check for tool patterns and integration procedures
   ```bash
   mcp_agent-memory_search_memory_nodes --query "tool development integration" --entity "Procedure"
   ```
2. **Directory**: `mkdir -p src/tools/<service_name>`
3. **Schema**: Define `ToolInput`/`ToolOutput` Pydantic models
4. **Provider**: Handle external API communication (if needed)
5. **Business Logic**: Async function with `RunContext`
6. **Interface**: Create `Tool` object with name, description, function
7. **Global Registration**: Add to `src/tools/__init__.py`
8. **Testing**: Unit (mocking) + integration (agent context)

### **API Endpoint** (5-Step Process)
1. **Search Memory**: Check for API patterns and security requirements
   ```bash
   mcp_agent-memory_search_memory_nodes --query "API endpoint security" --entity "Requirement"
   ```
2. **Models**: Define Pydantic request/response models
3. **Route Handler**: Create with `@router.post` and `Depends(verify_api_key)`
4. **Business Logic**: Implement endpoint functionality
5. **Testing**: Test with `TestClient` and API keys

## âš ï¸ Critical DO/DON'T Rules

### **Agent Development**
âœ… **DO**: 
- Search memory for established patterns first
- Extend `AutomagikAgent` base class
- Use `async def process_message()` pattern
- Register default tools: `self.tool_registry.register_default_tools()`
- Use memory templates: `{{user_name}}`, `{{recent_context}}`
- Store new patterns discovered

âŒ **DON'T**: 
- Skip memory search before implementation
- Modify `AutomagikAgent` base class directly
- Create agents bypassing framework
- Skip tool registration
- Hardcode user context

### **Tool Development**
âœ… **DO**: 
- Search for existing tool patterns
- Use `async def tool(ctx: RunContext[Dict], ...)`
- Return `ToolOutput(...).dict()`
- Handle errors gracefully (return error models)
- Validate inputs with Pydantic
- Document integration procedures

âŒ **DON'T**: 
- Ignore established patterns
- Raise exceptions from tools
- Use blocking operations in async context
- Skip registration workflow
- Hardcode API keys

### **API Development**
âœ… **DO**: 
- Check security requirements from memory
- Use `Depends(verify_api_key)` for `/api/v1/` endpoints
- Define Pydantic request/response models
- Return structured responses with HTTP status codes
- Handle errors with `HTTPException`

âŒ **DON'T**: 
- Bypass authentication middleware
- Use raw dictionaries instead of Pydantic models
- Return unstructured responses
- Ignore error handling

## ğŸ”§ Implementation Patterns

**Memory Templates**:
```python
SYSTEM_PROMPT = """You are an agent.
User: {{user_name}} | Preferences: {{user_preferences}}
Context: {{recent_context}} | Available tools: {tools}"""
```

**Agent Extension**:
```python
class MyAgent(AutomagikAgent):
    def __init__(self, config: Dict[str, str]) -> None:
        super().__init__(config)
        self._code_prompt_text = AGENT_PROMPT
        self.dependencies = AutomagikAgentsDependencies(...)
        self.tool_registry.register_default_tools(self.context)
```

**Tool Registration**:
```python
# interface.py
my_tool_object = Tool(name="service_tool", description="...", function=my_tool)
service_tools = [my_tool_object]

# __init__.py  
from .interface import service_tools
__all__ = ["service_tools"]

# src/tools/__init__.py
from .my_service import service_tools
__all__.append("service_tools")
```

## ğŸ§ª Testing Requirements & Organization

### **Test Directory Structure** (MANDATORY)
```
tests/
â”œâ”€â”€ unit/              # Isolated component testing
â”‚   â””â”€â”€ test_mcp_core.py
â”œâ”€â”€ integration/       # Multi-component testing
â”‚   â””â”€â”€ test_mcp_integration.py
â”œâ”€â”€ api/              # API endpoint testing
â”‚   â””â”€â”€ test_mcp_routes.py
â”œâ”€â”€ db/               # Database layer testing
â”‚   â””â”€â”€ test_mcp_repository.py
â”œâ”€â”€ tools/            # Tool-specific testing
â”œâ”€â”€ agents/           # Agent-specific testing
â”œâ”€â”€ utils/            # Utility function testing
â””â”€â”€ perf/             # Performance testing
```

### **File Placement Rules** âœ… **DO** / âŒ **DON'T**

âœ… **DO**:
- Search memory for test patterns before writing
- Place unit tests in `tests/unit/test_[module_name].py`
- Place integration tests in `tests/integration/test_[feature_name].py`
- Place API tests in `tests/api/test_[route_name].py`
- Use descriptive test file names matching component being tested
- **NEVER create test files at project root**

âŒ **DON'T**:
- Skip memory search for test procedures
- Create test files in project root directory (causes repo mess)
- Mix different test types in same file
- Use generic names like `test.py` or `temp_test.py`
- Skip test organization when debugging

### **Feature Testing Mandate**:
- **Unit Tests**: Test individual components in isolation
- **Integration Tests**: Test feature with framework components
- **Memory Tests**: Test memory persistence and retrieval

**Testing Pattern**:
```python
@pytest.mark.asyncio
async def test_agent_memory_integration():
    agent = MyAgent({})
    session = "test_session"
    
    await agent.process_message("Remember my preference: detailed", session)
    response = await agent.process_message("What's my preference?", session)
    
    assert "detailed" in response
```

## ğŸ“‹ Quality Control

**Before Task Completion**:
- [ ] Memory searched for established patterns
- [ ] All subtasks marked as done
- [ ] Code follows discovered procedures
- [ ] Tests written and passing (unit + integration + memory)
- [ ] Documentation updated
- [ ] New patterns stored in memory
- [ ] Rules updated if new patterns emerged

**Feature Placement Decision**:
- **Agent Features**: `src/agents/simple/[agent_name]/`
- **Tool Integration**: `src/tools/[service_name]/`
- **API Features**: `src/api/routes/`
- **Memory Features**: `src/memory/`
- **Cross-Cutting**: Coordinated implementation

## ğŸ’¾ Memory Integration

**Development Pattern Recording**:
```bash
# Before implementation
mcp_agent-memory_search_memory_nodes --query "implementation pattern" --entity "Procedure"

# During development - capture discoveries
mcp_agent-memory_add_memory \
  --name "AutomagikAgent Extension Procedure" \
  --episode_body "1. Call super().__init__\n2. Set _code_prompt_text\n3. Register tools" \
  --source "text"

# After completion - store successful patterns
mcp_agent-memory_add_memory \
  --name "Successful Pattern: [Feature]" \
  --episode_body "Key learnings and implementation details" \
  --source "text"
```

**Memory-Driven Development**:
1. **Search before coding**: Find established patterns
2. **Respect preferences**: Align with discovered preferences
3. **Follow procedures**: Use step-by-step workflows
4. **Capture immediately**: Store discoveries as you work
5. **Share knowledge**: Document for team benefit

---

**Remember**: Always search memory first, respect discovered knowledge, follow established procedures, and capture new patterns. The knowledge graph guides consistent development.
