---
description: 
globs: 
alwaysApply: false
---
# Logging & Error Handling Guidelines

Consistent logging makes debugging and monitoring possible in production.  These rules define *how* and *where* we log, plus how we surface and handle errors.

## 1. Standard Logger Setup

Each entry-point (scripts, server, agents) must configure the root logger exactly once:

```python
import logging
logging.basicConfig(
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    level=logging.INFO,
)
```

Libraries *never* call `basicConfig`; they obtain a child logger via:

```python
logger = logging.getLogger(__name__)
```

## 2. Log Levels

| Level | When to use |
|-------|-------------|
| `DEBUG` | Verbose internal state useful for local debugging (disabled in prod) |
| `INFO`  | High-level application events (agent start/stop, external API call) |
| `WARNING` | Recoverable problems, unexpected state but continuing |
| `ERROR` | Exceptions we catch but continue after compensating |
| `CRITICAL` | Unhandled fatal error – app will likely exit |

Default runtime level is `INFO` (can be overridden via `LOG_LEVEL` in config).

## 3. Structured Context Fields

Use *keyword arguments* or f-strings with explicit fields:

```python
logger.info("Sent email", extra={"to": input.to, "message_id": msg_id})
```

Avoid bare string concatenation; this keeps logs parseable by tools like Datadog.

## 4. Exceptions

Inside an `except` block, always call `logger.exception()` – it logs the stack trace automatically.

```python
try:
    risky()
except ExampleError:
    logger.exception("risky() failed – continuing with fallback")
```

Only swallow the error if a sane fallback exists; otherwise *re-raise*.

## 5. Correlation IDs

Web-facing entry-points should attach a `correlation_id` (UUID) to the `extra` dict so we can stitch logs of the same request.

## 6. Error Classes

1. Use custom exception types for domain errors (e.g. `EmailSendError`).
2. Derive them from `Exception`, not `BaseException`.
3. Never catch `Exception` globally without re-raising/logging.

## 7. External Service Calls

Log *before* the call (method + resource) and *after* with latency and status.

```python
start = time.time()
logger.info("GET /files", extra={"service": "google_drive"})
resp = drive.get_files()
logger.info("GET /files – success", extra={"duration_ms": (time.time()-start)*1000})
```

## 8. Sensitive Data

Never log secrets, passwords, JWTs or full email bodies.  Use placeholders or hashes.

## 9. Alerting

`CRITICAL` messages emitted in production should trigger pager duty; integration TBD.

## 10. Correlation IDs in Practice

Add a unique `correlation_id` per inbound HTTP request – propagated via RunContext so tools can include it.

```python
import uuid, logging
logger = logging.getLogger(__name__)

cid = uuid.uuid4().hex
logger.info("User logged in", extra={"correlation_id": cid})
```

When logging inside a tool, read the ID from `ctx.deps.context.get("correlation_id")`.

## 11. Production Sinks

• **Console** for dev, JSON formatted.
• **Datadog**: ship via `DD_API_KEY` env var; use structured JSON.
• **Logfire** token configured via `settings.LOGFIRE_TOKEN`.

## 12. AI Agent Guidance

• Never use `print()` for diagnostics—always `logger.debug`/`info`.
• Always include contextual fields (`extra={...}`) instead of string interpolation.
• Don't change global log level; override via `AM_LOG_LEVEL` env var when scripting.
